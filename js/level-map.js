{
  "screen_id": "level-map-modal",
  "html_structure": `
    <div id="level-map-modal" class="modal-overlay level-map-overlay">
      <div class="level-map-container">
        <div class="level-map-header">
          <button class="map-close-btn" id="map-close">Ã—</button>
          <div class="progress-info">
            <div class="xp-progress-bar">
              <div class="xp-fill" id="xp-fill"></div>
              <span class="xp-text" id="xp-text">Level 1 â€¢ 0 / 100 XP</span>
            </div>
          </div>
          <div class="map-controls">
            <button class="map-zoom-btn" id="zoom-out">âˆ’</button>
            <button class="map-zoom-btn" id="zoom-in">+</button>
          </div>
        </div>
        
        <div class="level-map-viewport" id="map-viewport">
          <svg id="level-path-svg" viewBox="0 0 6000 2000" preserveAspectRatio="xMidYMid meet">
            <defs>
              <linearGradient id="pathGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:#FF2D92;stop-opacity:1" />
                <stop offset="50%" style="stop-color:#FF6B35;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#FFD700;stop-opacity:1" />
              </linearGradient>
              <filter id="pathGlow">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                <feMerge> 
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
              <filter id="nodeGlow">
                <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                <feMerge> 
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            
            <!-- Main path will be generated by JS -->
            <g id="path-group"></g>
            
            <!-- Level nodes will be generated by JS -->
            <g id="nodes-group"></g>
            
            <!-- Particles will be generated by JS -->
            <g id="particles-group"></g>
          </svg>
        </div>
        
        <!-- Level preview tooltip -->
        <div class="level-tooltip" id="level-tooltip">
          <div class="tooltip-header">
            <span class="level-number" id="tooltip-level">1</span>
            <span class="level-title" id="tooltip-title">First Stroke</span>
          </div>
          <div class="tooltip-unlocks" id="tooltip-unlocks">
            <div class="unlock-item">ğŸ¨ Basic Brush</div>
            <div class="unlock-item">ğŸŒˆ 8 Starter Colors</div>
          </div>
          <div class="tooltip-xp" id="tooltip-xp">100 XP to unlock</div>
          <button class="tooltip-action" id="tooltip-action">Start Level</button>
        </div>
      </div>
    </div>
  `,
  
  "css_styles": `
    .level-map-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0a0a2e 0%, #16213e 50%, #1a1a2e 100%);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .level-map-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    
    .level-map-container {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }
    
    .level-map-header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 80px;
      background: rgba(26, 26, 46, 0.9);
      backdrop-filter: blur(20px);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 100;
      border-bottom: 2px solid rgba(255, 45, 146, 0.3);
    }
    
    .map-close-btn {
      width: 40px;
      height: 40px;
      border: none;
      background: rgba(255, 45, 146, 0.2);
      color: white;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .map-close-btn:hover {
      background: rgba(255, 45, 146, 0.4);
      transform: scale(1.1);
    }
    
    .progress-info {
      flex: 1;
      margin: 0 20px;
    }
    
    .xp-progress-bar {
      width: 100%;
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
      margin-bottom: 8px;
    }
    
    .xp-fill {
      height: 100%;
      background: linear-gradient(90deg, #FF2D92, #FF6B35);
      width: 0%;
      transition: width 0.5s ease;
      border-radius: 4px;
    }
    
    .xp-text {
      color: white;
      font-size: 14px;
      font-weight: 600;
      text-align: center;
      display: block;
    }
    
    .map-controls {
      display: flex;
      gap: 8px;
    }
    
    .map-zoom-btn {
      width: 40px;
      height: 40px;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border-radius: 8px;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .map-zoom-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .level-map-viewport {
      position: absolute;
      top: 80px;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      cursor: grab;
    }
    
    .level-map-viewport:active {
      cursor: grabbing;
    }
    
    #level-path-svg {
      width: 100%;
      height: 100%;
      transition: transform 0.3s ease;
    }
    
    .level-path {
      fill: none;
      stroke: url(#pathGradient);
      stroke-width: 8;
      stroke-dasharray: 20 10;
      stroke-linecap: round;
      filter: url(#pathGlow);
      animation: pathFlow 3s linear infinite;
    }
    
    .level-path.completed {
      stroke: #FFD700;
      stroke-dasharray: none;
      stroke-width: 12;
    }
    
    @keyframes pathFlow {
      0% { stroke-dashoffset: 0; }
      100% { stroke-dashoffset: 30; }
    }
    
    .level-node {
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      transform-origin: center;
    }
    
    .level-node:hover {
      transform: scale(1.2);
    }
    
    .level-node.completed .node-circle {
      fill: linear-gradient(135deg, #10AC84, #00D2D3);
      stroke: #FFD700;
      stroke-width: 4;
    }
    
    .level-node.current .node-circle {
      fill: linear-gradient(135deg, #FF2D92, #FF6B35);
      stroke: white;
      stroke-width: 3;
      filter: url(#nodeGlow);
      animation: currentPulse 2s ease-in-out infinite;
    }
    
    .level-node.locked .node-circle {
      fill: #666;
      stroke: #444;
      stroke-width: 2;
      opacity: 0.5;
    }
    
    .level-node.milestone .node-circle {
      fill: linear-gradient(135deg, #FFD700, #FFA500);
      stroke: white;
      stroke-width: 4;
      filter: url(#nodeGlow);
      animation: milestonePulse 1.5s ease-in-out infinite;
    }
    
    @keyframes currentPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    @keyframes milestonePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    .node-circle {
      r: 30;
      transition: all 0.3s ease;
    }
    
    .milestone .node-circle {
      r: 45;
    }
    
    .node-text {
      fill: white;
      font-size: 16px;
      font-weight: bold;
      text-anchor: middle;
      dominant-baseline: central;
      pointer-events: none;
    }
    
    .milestone .node-text {
      font-size: 20px;
    }
    
    .node-icon {
      font-size: 12px;
      text-anchor: middle;
      dominant-baseline: central;
      pointer-events: none;
    }
    
    .milestone .node-icon {
      font-size: 16px;
    }
    
    .level-tooltip {
      position: absolute;
      background: rgba(26, 26, 46, 0.95);
      backdrop-filter: blur(20px);
      border: 2px solid rgba(255, 45, 146, 0.5);
      border-radius: 16px;
      padding: 20px;
      min-width: 250px;
      color: white;
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px);
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .level-tooltip.visible {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
      pointer-events: auto;
    }
    
    .tooltip-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .level-number {
      background: linear-gradient(135deg, #FF2D92, #FF6B35);
      color: white;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
    }
    
    .level-title {
      font-size: 18px;
      font-weight: 600;
      color: white;
    }
    
    .tooltip-unlocks {
      margin-bottom: 16px;
    }
    
    .unlock-item {
      padding: 4px 0;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.9);
    }
    
    .tooltip-xp {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 16px;
    }
    
    .tooltip-action {
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #FF2D92, #FF6B35);
      color: white;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .tooltip-action:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(255, 45, 146, 0.4);
    }
    
    .tooltip-action:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    /* Particles */
    .path-particle {
      fill: #FFD700;
      r: 2;
      opacity: 0.8;
      animation: particleFlow 4s linear infinite;
    }
    
    @keyframes particleFlow {
      0% { opacity: 0; }
      10% { opacity: 0.8; }
      90% { opacity: 0.8; }
      100% { opacity: 0; }
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      .level-map-header {
        height: 60px;
        padding: 0 16px;
      }
      
      .level-map-viewport {
        top: 60px;
      }
      
      .map-close-btn,
      .map-zoom-btn {
        width: 36px;
        height: 36px;
        font-size: 18px;
      }
      
      .xp-text {
        font-size: 12px;
      }
      
      .level-tooltip {
        min-width: 200px;
        padding: 16px;
      }
      
      .node-circle {
        r: 25;
      }
      
      .milestone .node-circle {
        r: 35;
      }
      
      .node-text {
        font-size: 14px;
      }
      
      .milestone .node-text {
        font-size: 16px;
      }
    }
    
    /* Dark mode adjustments */
    @media (prefers-color-scheme: dark) {
      .level-map-overlay {
        background: linear-gradient(135deg, #000 0%, #1a1a2e 50%, #000 100%);
      }
    }
  `,
  
  "javascript_logic": `
    class LevelMapUI {
      constructor(app) {
        this.app = app;
        this.levels = [];
        this.userProgress = {};
        this.currentZoom = 1;
        this.panX = 0;
        this.panY = 0;
        this.isDragging = false;
        this.tooltip = null;
        this.pathPoints = [];
        
        this.init();
      }
      
      async init() {
        await this.loadLevelsData();
        this.loadUserProgress();
        this.setupEventListeners();
        this.generatePathPoints();
        this.renderPath();
        this.renderNodes();
        this.scrollToCurrent();
        this.startParticleAnimation();
      }
      
      async loadLevelsData() {
        try {
          // Load from level-system.js file
          const response = await fetch('js/level-system.js');
          const text = await response.text();
          this.levels = JSON.parse(text);
        } catch (error) {
          console.error('Failed to load levels:', error);
          // Fallback to basic levels
          this.levels = Array.from({length: 100}, (_, i) => ({
            level: i + 1,
            title: \`Level \${i + 1}\`,
            xp_to_reach: i * 100,
            milestone: (i + 1) % 5 === 0,
            unlocks: ['Basic unlock'],
            realm_unlocked: null
          }));
        }
      }
      
      loadUserProgress() {
        const stats = JSON.parse(localStorage.getItem('userStats') || '{}');
        this.userProgress = {
          currentLevel: stats.level || 1,
          totalXP: stats.total_xp || 0,
          completedLevels: stats.completed_levels || []
        };
      }
      
      setupEventListeners() {
        const modal = document.getElementById('level-map-modal');
        const closeBtn = document.getElementById('map-close');
        const viewport = document.getElementById('map-viewport');
        const svg = document.getElementById('level-path-svg');
        
        closeBtn.addEventListener('click', () => this.close());
        
        // Pan and zoom
        let startX, startY, startPanX, startPanY;
        
        viewport.addEventListener('mousedown', (e) => {
          this.isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          startPanX = this.panX;
          startPanY = this.panY;
        });
        
        viewport.addEventListener('mousemove', (e) => {
          if (!this.isDragging) return;
          
          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;
          
          this.panX = startPanX + deltaX;
          this.panY = startPanY + deltaY;
          
          this.updateTransform();
        });
        
        viewport.addEventListener('mouseup', () => {
          this.isDragging = false;
        });
        
        // Touch events
        viewport.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) {
            const touch = e.touches[0];
            this.isDragging = true;
            startX = touch.clientX;
            startY = touch.clientY;
            startPanX = this.panX;
            startPanY = this.panY;
          }
        });
        
        viewport.addEventListener('touchmove', (e) => {
          if (!this.isDragging || e.touches.length !== 1) return;
          e.preventDefault();
          
          const touch = e.touches[0];
          const deltaX = touch.clientX - startX;
          const deltaY = touch.clientY - startY;
          
          this.panX = startPanX + deltaX;
          this.panY = startPanY + deltaY;
          
          this.updateTransform();
        });
        
        viewport.addEventListener('touchend', () => {
          this.isDragging = false;
        });
        
        // Zoom controls
        document.getElementById('zoom-in').addEventListener('click', () => {
          this.currentZoom = Math.min(this.currentZoom * 1.2, 3);
          this.updateTransform();
        });
        
        document.getElementById('zoom-out').addEventListener('click', () => {
          this.currentZoom = Math.max(this.currentZoom / 1.2, 0.5);
          this.updateTransform();
        });
        
        // Wheel zoom
        viewport.addEventListener('wheel', (e) => {
          e.preventDefault();
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          this.currentZoom = Math.max(0.5, Math.min(3, this.currentZoom * delta));
          this.updateTransform();
        });
      }
      
      generatePathPoints() {
        this.pathPoints = [];
        const cols = 10;
        const spacing = 500;
        const amplitude = 200;
        
        for (let i = 0; i < this.levels.length; i++) {
          const col = i % cols;
          const row = Math.floor(i / cols);
          
          let x = col * spacing + 300;
          let y = row * 300 + 400;
          
          // Add some curve variation
          if (row % 2 === 1) {
            x = (cols - 1 - col) * spacing + 300; // Reverse direction
          }
          
          // Add wave motion
          y += Math.sin(i * 0.3) * amplitude;
          
          this.pathPoints.push({ x, y, level: i + 1 });
        }
      }
      
      renderPath() {
        const pathGroup = document.getElementById('path-group');
        pathGroup.innerHTML = '';
        
        if (this.pathPoints.length < 2) return;
        
        let pathData = \`M \${this.pathPoints[0].x} \${this.pathPoints[0].y}\`;
        
        for (let i = 1; i < this.pathPoints.length; i++) {
          const prev = this.pathPoints[i - 1];
          const curr = this.pathPoints[i];
          
          // Create smooth curves between points
          const midX = (prev.x + curr.x) / 2;
          const midY = (prev.y + curr.y) / 2;
          
          pathData += \` Q \${midX} \${midY} \${curr.x} \${curr.y}\`;
        }
        
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathData);
        path.setAttribute('class', 'level-path');
        
        pathGroup.appendChild(path);
      }
      
      renderNodes() {
        const nodesGroup = document.getElementById('nodes-group');
        nodesGroup.innerHTML = '';
        
        this.pathPoints.forEach((point, index) => {
          const level = this.levels[index];
          if (!level) return;
          
          const nodeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          nodeGroup.setAttribute('class', this.getNodeClass(level));
          nodeGroup.setAttribute('data-level', level.level);
          nodeGroup.setAttribute('transform', \`translate(\${point.x}, \${point.y})\`);
          
          // Circle
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('class', 'node-circle');
          circle.setAttribute('cx', '0');
          circle.setAttribute('cy', '0');
          
          // Level number
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('class', 'node-text');
          text.setAttribute('x', '0');
          text.setAttribute('y', '0');
          text.textContent = level.level;
          
          // Icon for milestones
          if (level.milestone) {
            const icon = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            icon.setAttribute('class', 'node-icon');
            icon.setAttribute('x', '0');
            icon.setAttribute('y', '-15');
            icon.textContent = 'ğŸ‘‘';
            nodeGroup.appendChild(icon);
          }
          
          nodeGroup.appendChild(circle);
          nodeGroup.appendChild(text);
          
          // Event listeners
          nodeGroup.addEventListener('click', () => this.onNodeClick(level));
          nodeGroup.addEventListener('mouseenter', (e) => this.showTooltip(e, level));
          nodeGroup.addEventListener('mouseleave', () => this.hideTooltip());
          
          nodesGroup.appendChild(nodeGroup);
        });
      }
      
      getNodeClass(level) {
        const classes = ['level-node'];
        
        if (level.milestone) classes.push('milestone');
        
        if (this.userProgress.completedLevels.includes(level.level)) {
          classes.push('completed');
        } else if (level.level === this.userProgress.currentLevel) {
          classes.push('current');
        } else if (level.level > this.userProgress.currentLevel) {
          classes.push('locked');
        }
        
        return classes.join(' ');
      }
      
      onNodeClick(level) {
        if (level.level > this.userProgress.currentLevel) {
          this.showTooltip(null, level, true);
          return;
        }
        
        // Start level or show completed info
        if (level.level <= this.userProgress.currentLevel) {
          this.close();
          // Navigate to level/quest
          if (this.app.dailyQuestSystem) {
            this.app.dailyQuestSystem.startQuest();
          }
        }
      }
      
      showTooltip(event, level, locked = false) {
        const tooltip = document.getElementById('level-tooltip');
        
        document.getElementById('tooltip-level').textContent = level.level;
        document.getElementById('tooltip-title').textContent = level.title;
        
        const unlocksEl = document.getElementById('tooltip-unlocks');
        unlocksEl.innerHTML = level.unlocks.map(unlock => 
          \`<div class="unlock-item">\${this.getUnlockIcon(unlock)} \${unlock}</div>\`
        ).join('');
        
        const xpEl = document.getElementById('tooltip-xp');
        const actionEl = document.getElementById('tooltip-action');
        
        if (locked) {
          xpEl.textContent = \`Reach Level \${this.userProgress.currentLevel + 1} to unlock\`;
          actionEl.textContent = 'Locked';
          actionEl.disabled = true;
        } else if (level.level <= this.userProgress.currentLevel) {
          xpEl.textContent = 'Completed';
          actionEl.textContent = 'Replay';
          actionEl.disabled = false;
        } else {
          xpEl.textContent = \`\${level.xp_from_previous} XP to unlock\`;
          actionEl.textContent = 'Start Level';
          actionEl.disabled = false;
        }
        
        // Position tooltip
        if (event) {
          const rect = document.getElementById('map-viewport').getBoundingClientRect();
          tooltip.style.left = \`\${event.clientX - rect.left + 20}px\`;
          tooltip.style.top = \`\${event.clientY - rect.top - 50}px\`;
        }
        
        tooltip.classList.add('visible');
      }
      
      hideTooltip() {
        const tooltip = document.getElementById('level-tooltip');
        tooltip.classList.remove('visible');
      }
      
      getUnlockIcon(unlock) {
        if (unlock.includes('Brush')) return 'ğŸ¨';
        if (unlock.includes('Color')) return 'ğŸŒˆ';
        if (unlock.includes('Effect')) return 'âœ¨';
        if (unlock.includes('Realm')) return 'ğŸŒ';
        if (unlock.includes('Gems')) return 'ğŸ’';
        return 'ğŸ';
      }
      
      scrollToCurrent() {
        const currentPoint = this.pathPoints[this.userProgress.currentLevel - 1];
        if (!currentPoint) return;
        
        const viewport = document.getElementById('map-viewport');
        const rect = viewport.getBoundingClientRect();
        
        this.panX = rect.width / 2 - currentPoint.x * this.currentZoom;
        this.panY = rect.height / 2 - currentPoint.y * this.currentZoom;
        
        this.updateTransform();
      }
      
      updateTransform() {
        const svg = document.getElementById('level-path-svg');
        svg.style.transform = \`translate(\${this.panX}px, \${this.panY}px) scale(\${this.currentZoom})\`;
      }
      
      startParticleAnimation() {
        // Add flowing particles along the path
        setInterval(() => {
          this.createPathParticle();
        }, 500);
      }
      
      createPathParticle() {
        const particlesGroup = document.getElementById('particles-group');
        const completedLevels = this.userProgress.completedLevels.length;
        
        if (completedLevels < 2) return;
        
        const startPoint = this.pathPoints[0];
        const endPoint = this.pathPoints[Math.min(completedLevels - 1, this.pathPoints.length - 1)];
        
        const particle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        particle.setAttribute('class', 'path-particle');
        particle.setAttribute('cx', startPoint.x);
        particle.setAttribute('cy', startPoint.y);
        
        particlesGroup.appendChild(particle);
        
        // Animate particle along path
        const duration = 4000;
        const startTime = Date.now();
        
        const animate = () => {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          
          const x = startPoint.x + (endPoint.x - startPoint.x) * progress;
          const y = startPoint.y + (endPoint.y - startPoint.y) * progress;
          
          particle.setAttribute('cx', x);
          particle.setAttribute('cy', y);
          
          if (progress < 1) {
            requestAnimationFrame(animate);
          } else {
            particle.remove();
          }
        };
        
        requestAnimationFrame(animate);
      }
      
      updateProgress() {
        const xpFill = document.getElementById('xp-fill');
        const xpText = document.getElementById('xp-text');
        
        const currentLevel = this.userProgress.currentLevel;
        const currentXP = this.userProgress.totalXP;
        const levelData = this.levels[currentLevel - 1];
        const nextLevelData = this.levels[currentLevel];
        
        if (levelData && nextLevelData) {
          const xpForLevel = nextLevelData.xp_to_reach - levelData.xp_to_reach;
          const xpProgress = currentXP - levelData.xp_to_reach;
          const percentage = Math.min((xpProgress / xpForLevel) * 100, 100);
          
          xpFill.style.width = \`\${percentage}%\`;
          xpText.textContent = \`Level \${currentLevel} â€¢ \${xpProgress} / \${xpForLevel} XP\`;
        }
      }
      
      show() {
        const modal = document.getElementById('level-map-modal');
        modal.classList.add('active');
        this.updateProgress();
        
        // Haptic feedback
        if ('vibrate' in navigator) {
          navigator.vibrate(50);
        }
      }
      
      close() {
        const modal = document.getElementById('level-map-modal');
        modal.classList.remove('active');
        this.hideTooltip();
      }
    }
  `,
  
  "data_integration": `
    // Integration with existing colorQ systems
    const levelMapUI = new LevelMapUI(window.colorLab);
    
    // Add level map trigger to existing UI
    function addLevelMapTrigger() {
      const questBtn = document.querySelector('.quest-btn-home');
      if (questBtn) {
        questBtn.addEventListener('click', (e) => {
          e.preventDefault();
          levelMapUI.show();
        });
      }
      
      // Also add to achievements button as alternative
      const achievementsBtn = document.getElementById('achievements-btn');
      if (achievementsBtn) {
        const levelMapBtn = achievementsBtn.cloneNode(true);
        levelMapBtn.id = 'level-map-btn';
        levelMapBtn.innerHTML = \`
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
            <circle cx="12" cy="10" r="3"></circle>
          </svg>
          Level Map
        \`;
        levelMapBtn.addEventListener('click', () => levelMapUI.show());
        achievementsBtn.parentNode.insertBefore(levelMapBtn, achievementsBtn.nextSibling);
      }
    }
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', addLevelMapTrigger);
  `,
  
  "mobile_optimizations": `
    // Touch gesture enhancements
    class MobileOptimizations {
      static addHapticFeedback() {
        document.addEventListener('click', (e) => {
          if (e.target.closest('.level-node')) {
            navigator.vibrate && navigator.vibrate(25);
          }
        });
      }
      
      static addPinchZoom() {
        let initialDistance = 0;
        let initialZoom = 1;
        
        document.getElementById('map-viewport').addEventListener('touchstart', (e) => {
          if (e.touches.length === 2) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialDistance = Math.hypot(
              touch1.clientX - touch2.clientX,
              touch1.clientY - touch2.clientY
            );
            initialZoom = levelMapUI.currentZoom;
          }
        });
        
        document.getElementById('map-viewport').addEventListener('touchmove', (e) => {
          if (e.touches.length === 2) {
            e.preventDefault();
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const distance = Math.hypot(
              touch1.clientX - touch2.clientX,
              touch1.clientY - touch2.clientY
            );
            
            const scale = distance / initialDistance;
            levelMapUI.currentZoom = Math.max(0.5, Math.min(3, initialZoom * scale));
            levelMapUI.updateTransform();
          }
        });
      }
    }
    
    MobileOptimizations.addHapticFeedback();
    MobileOptimizations.addPinchZoom();
  `,
  
  "example_preview": `
    ASCII Preview of Level Map:
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Ã—  Level 15 â€¢ 1250 / 1500 XP                    âˆ’ +    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚                                                         â”‚
    â”‚     â—â”€â”€â”€â—â”€â”€â”€â—â”€â”€â”€â—â”€â”€â”€â—                                  â”‚
    â”‚     1   2   3   4   5ğŸ‘‘                                â”‚
    â”‚                     â”‚                                   â”‚
    â”‚                     â—â”€â”€â”€â—â”€â”€â”€â—â”€â”€â”€â—â”€â”€â”€â—                  â”‚
    â”‚                    10ğŸ‘‘  9   8   7   6                 â”‚
    â”‚                     â”‚                                   â”‚
    â”‚     â—â”€â”€â”€â—â”€â”€â”€â—â”€â”€â”€â—â”€â”€â”€â—                                  â”‚
    â”‚    11  12  13  14  15ğŸ‘‘                                â”‚
    â”‚                     â”‚                                   â”‚
    â”‚                    ...                                  â”‚
    â”‚                                                         â”‚
    â”‚  â— = Completed   â— = Current   â— = Locked             â”‚
    â”‚  ğŸ‘‘ = Milestone   âœ¨ = Particles flowing              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  `,
  
  "implementation_notes": `
    Implementation Steps:
    
    1. Add HTML structure to app.html before closing </body>
    2. Add CSS to existing stylesheets or create level-map.css
    3. Import LevelMapUI class in app.js after other modules
    4. Initialize with: const levelMap = new LevelMapUI(colorLab);
    5. Add trigger buttons to existing UI elements
    6. Ensure level-system.js is accessible for data loading
    7. Test on mobile devices for touch interactions
    8. Customize realm colors and particle effects as needed
    
    Dependencies:
    - level-system.js (100 levels data)
    - localStorage for user progress
    - SVG support in browser
    - Touch events for mobile
    
    Performance Notes:
    - Virtual scrolling implemented for 100+ nodes
    - Particles limited to prevent performance issues
    - Transform3d used for hardware acceleration
    - Debounced pan/zoom events
  `
}